#!/bin/julia

#println("Mapping Symbols to values.")
#---------------------------------------------------------------------- 
# Map to actual values
@doc """
      Map2Values(θ::AbstractVector{T},Q::AbstractArray{T},NC::Int,NP::Int,NS::Int,NLO::Int,Ztol::Float64) where {T}

      Create a vector/Matrix of Tuples to Map θ and Q symbols to values generated by Nek.

      Retruns θmap, Qmap

"""
#---------------------------------------------------------------------- 
function Map2Values(θ::AbstractVector{T},Q::AbstractArray{T},NC::Int,NP::Int,NS::Int,NLO::Int,Ztol::Float64) where {T}

  # Tolerance for removing small terms.
  # If this is exactly zero then small term removal is effectively disabled.
  println("Small Term Tolerance: $(Ztol)")

  Λ, WtV, Adv, Lap, Lap0 = ReadNekCMFiles()
 
  DM    = NC + NS
  NM    = NC + NP + NS  # No. of Modes

  SType = eltype(θ)
  θmap  = Vector{Tuple{SType,Complex}}(undef,NM)
  for i in 1:NC
    symb      = θ[i]
    val       = Λ[i,1]
    θmap[i]   = tuple(symb,val)
  end
  for i in 1:NP
    j         = NC+i
    symb      = θ[j]
    val       = 0.0 + im*0.0
    θmap[j]   = tuple(symb,val)
  end
  for i in 1:NS
    j         = NC+NP+i
    symb      = θ[j]
    k         = NC+i
    val       = Λ[k,1]
    θmap[j]   = tuple(symb,val)
  end
  
  maxterms = TotalInteractionTerms(NLO,NM)
  nlt      = NInteractionTerms(1,NM)
  Qmap     = Matrix{Tuple{SType,Complex}}(undef,maxterms,NM)

  # Map Linear Symbols
  for k in 1:NM
    for j in 1:nlt
      symb = Q[j,1,k]
      if k == j
        l   = oldindex(j,NC,NP,NS)
        val = Λ[l,1]
        if l>DM
          val = 0
        end  
        Qmap[j,k] = tuple(symb,val)
      elseif j == NC+1
        i   = oldindex(k,NC,NP,NS)
        val = Lap0[i]
        Qmap[j,k] = tuple(symb,val)
      else
        val = 0
        Qmap[j,k] = tuple(symb,val)
      end
    end     # j in 1:lt
  end       # k in 1:NM 

  
  # Map the nonlinear symbols
  for k in 1:NM
    jn = 0
    p  = fill(0,1,NM)
    for l in (nlt+1):maxterms
      pw     = view(p,1,:)
      jn     = NextRow!(pw,NLO,jn)
      i1,j1  = InteractionNTuples(p,NLO,NM)
      i2     = oldindex(i1,NC,NP,NS) 
      j2     = oldindex(j1,NC,NP,NS)
      k2     = oldindex(k,NC,NP,NS)
      
      symb   = Q[l-nlt,2,k]
      if (k2<=DM)
        if (i2<=DM) && (j2<=DM)
          # This maps to the advection terms
          val  = -(Adv[i2,j2,k2] + Adv[j2,i2,k2])
        else
          # This maps to the Laplacian
          if i2>DM && j2>DM
            # No parameter-parameter interaction terms
            val = 0
          elseif (i2<=DM)
            val  = Lap[i2,k2]
          elseif (j2<=DM)
            val  = Lap[j2,k2]
          end
        end         # advection or laplacian?
      else
        # Zero time evolution of parameter terms
        val       = 0
      end     # k2<=DM
      if (abs(val) < Ztol )
        val = 0*val
      end  
      Qmap[l,k] = tuple(symb,val)
    end       # l in 1:nt3 
  end         # k in 1:nmodes

  return θmap,Qmap
end
#----------------------------------------------------------------------
@doc """

      MapQ2ABC(Q::AbstractArray{T},NC::Int,NP::Int,NS::Int,NLO::Int) where {T}

      Map symbols in Q to A,B,C symbols where,

      A     - Symbols for interaction terms within Center Manifold
      B     - Symbols for cross-interaction terms
      C     - Symbols for interaction terms of stable modes.

      Returns Q2ABC matrix of tuples.

"""
function MapQ2ABC(Q::AbstractArray{T},NC::Int,NP::Int,NS::Int,NLO::Int) where {T}

  DM    = NC + NS       # Dynamic modes
  NM    = NC + NP + NS  # No. of Modes
  CM    = NC + NP       # No. of Center Manifold modes
 
  maxterms = NInteractionTerms(NLO,NM)
  Q2ABC    = Matrix{Tuple{T,T}}(undef,maxterms,NM)

  Astr     = "A"  # Center manifold terms
  Bstr     = "B"  # Cross-terms
  Cstr     = "C"  # Stable/slaved terms
   
  # Map the nonlinear symbols
  for k in 1:NM
    jn = 0
    p  = fill(0,1,NM)
    for l in 1:maxterms
      pw     = view(p,1,:)
      jn     = NextRow!(pw,NLO,jn)
      i1,j1  = InteractionNTuples(p,maxp,NM)
      # i2     = oldindex(i1,NC,NP,NS) 
      # j2     = oldindex(j1,NC,NP,NS)
      # k2     = oldindex(k,NC,NP,NS)
      
      symb   = Q[l,k]
      if (i1<=CM) && (j1<=CM)
        # These are CenterManifold non-linearities
        str  = Astr*"_$(i1)_$(j1)"
      elseif (i1>CM && j1>CM)
        # These are Slaved term nonlinearities
        i1 = i1 - CM
        j1 = j1 - CM
        str  = Cstr*"_$(i1)_$(j1)"
      else
        # These are cross terms
        if i1>CM
          i1 = i1 - CM
        end
        if j1>CM
          j1 = j1 - CM
        end
        str  = Bstr*"_$(i1)_$(j1)"
      end
      sabc       = Sym(str)
      Q2ABC[l,k] = tuple(symb,sabc)
    end       # l in 1:maxterms 
  end         # k in 1:nmodes

  return Q2ABC
end
#---------------------------------------------------------------------- 
@doc """

      Mapθ2λ(θ::AbstractVector{T},NC::Int,NP::Int,NS::Int) where {T}

      Map θ symbols to λc and λs symbols where,

      λc    - Critical modes. Parameter eigenvalues are set to zero.
      λs    - Stable modes.

      Returns θ2λmap vector of tuples.

"""
function Mapθ2λ(θ::AbstractVector{T},NC::Int,NP::Int,NS::Int) where {T}

  NM = NC + NP + NS

  λc = GenerateSymbols("λc",NC)    # Eigenvalues of Critical modes
  λs = GenerateSymbols("λs",NS)    # Eigenvalues of Stable modes

  θ2λmap = Vector{Tuple{T,T}}(undef,NM)
  for i in 1:NC
    symb      = θ[i]
    symb2     = λc[i]
    θ2λmap[i]  = tuple(symb,symb2) 
  end
  for i in 1:NP
    j         = NC+i
    symb      = θ[j]
    θ2λmap[j]  = tuple(symb,0)
  end
  for i in 1:NS
    j         = NC+NP+i
    symb      = θ[j]
    symb2     = λs[i]
    θ2λmap[j]  = tuple(symb,symb2)
  end

  return θ2λmap
end
#---------------------------------------------------------------------- 
@doc """

      MapX2CSP(θ::AbstractVector{T},NC::Int,NP::Int,NS::Int) where {T}

      Map generic variable symbols X to Critical, Parameter and Stable mode symbols

      C     - Critical modes.
      P     - Parameter modes
      S     - Stable modes.

      Returns X2c,X2p,X2s vector of tuples.

"""
function MapX2CSP(X::AbstractVector{T},strc::String,strp::String,strs::String,NC::Int,NP::Int,NS::Int) where {T}

  NM = NC + NP + NS

  c  = GenerateSymbols(strc,NC)    # Critical modes
  s  = GenerateSymbols(strs,NS)    # Stable modes
  μ  = GenerateSymbols(strp,NP)    # Parameter modes

  X2c = Vector{Tuple{T,T}}(undef,NC)
  for i in 1:NC
    symb      = X[i]
    symb2     = c[i]
    X2c[i]    = tuple(symb,symb2) 
  end

  X2p = Vector{Tuple{T,T}}(undef,NP)
  for i in 1:NP
    j         = NC+i
    symb      = X[j]
    symb2     = μ[i]
    X2p[i]    = tuple(symb,symb2)
  end

  X2s = Vector{Tuple{T,T}}(undef,NS)
  for i in 1:NS
    j         = NC+NP+i
    symb      = X[j]
    symb2     = s[i]
    X2s[i]    = tuple(symb,symb2)
  end

  return X2c,X2p,X2s
end
#---------------------------------------------------------------------- 
@doc """

      function MapSolutions(α_e::AbstractArray{T},α::AbstractArray{T},θdict::Dict,Qdict::Dict,NC::Int,NP::Int,NS::Int,ApxO::Int) where {T}

      Substitute Q (non-linear interactions) and λ (eigenvalues) into expressions for solutions α

"""
function MapSolutions(α_e::AbstractArray{T},α::AbstractArray{T},θdict::Dict,Qdict::Dict,NC::Int,NP::Int,NS::Int,ApxO::Int) where {T}

  CMD = NC+NP     # Center Manifold dimension
  zro = 0.0+im*0.0
  # α-solutions as values (Complex)
  α_values  = fill(zro,size(α))
  # Dictionary to map α to solutions
  α_dict    = Matrix{Dict{Sym,Complex}}(undef,ApxO,NS)
  nall      = TotalInteractionTerms(ApxO,CMD)
  nall      = nall*NS

  # Vector for all mapped α.
  w         = Vector{Tuple{Sym,Complex}}(undef,nall)

  q = 0     # Counter for all
  # Approximate "α" Order-by-Order
  for AOrd in 1:ApxO
 
    # Number of terms in this order
    AOterms   = CenterManifold.NInteractionTerms(AOrd,CMD)
  
    if AOrd == 1
  
      for k in 1:NS

        # Mapping vector for this order (and Stable variable)
        v = Vector{Tuple{Sym,Complex}}(undef,AOterms)
        for i in 1:AOterms
          v[i]                = (α[i,AOrd,k],zro)
          α_values[i,AOrd,k]  = zro

          q = q+1
          w[q] = (α[i,AOrd,k],zro)
        end
        α_dict[AOrd,k] = Dict(v)
      end  
  
    else
      for k in 1:NS
        # Mapping vector for this order (and Stable variable)
        v = Vector{Tuple{Sym,Complex}}(undef,AOterms)
        for i in 1:AOterms
          symb    = α[i,AOrd,k] 

          # Expression of the solution      
          sol     = α_e[i,AOrd,k]

          # Substitute Q-values
          sol     = subs(sol,Qdict)

          # Substitute Eigenvalues
          sol     = subs(sol,θdict)

          # Substitute lower order solutions
          for m in 1:AOrd-1
            # Substitute α values from Lower Order
            for n in 1:NS
              sol = subs(sol,α_dict[m,n])
            end
          end
          # We should have no more symbols at this stage
          sval                = float(sol)
          v[i]                = tuple(symb,sval)
          α_values[i,AOrd,k]  = sval

          q      += 1
          w[q]    = tuple(symb,sval)
        end
        # convert v to dictionary
        α_dict[AOrd,k] = Dict(v)
      end     # k in 1:NS
    end       # AOrd == 1  
  end         # AOrd in 1:ApxO

  αall = Dict(w)

  return α_dict,αall,α_values
end  
#---------------------------------------------------------------------- 










