# I should turn this into a module when i'm done editing

#---------------------------------------------------------------------- 
@doc """
      GetNCritical(Λ::Vector{Number},tol::Float64)

      Get No. of modes with zero real parts

"""
function GetNCritical(Λ::Vector{T},tol::Float64) where {T <: Number}

  l = length(Λ)
  n = 0
  for λ in Λ
    if abs(real(λ)) < abs(tol)
      n += 1
    end
  end

  return n
end
#----------------------------------------------------------------------
@doc """
      ReadNekCMFiles()

      Read the Center Manifold files generated by Nek.
      Required Files: Lambda.out, AdvectionR.out, AdvectionI.out, LaplacianR.out, LaplacianI.out

"""
function ReadNekCMFiles()

  # Reading the Nek Outputs
  #------------------------------  
  fλ          = "Lambda.out"
  f           = CSV.File(fλ,stripwhitespace=true,delim=' ',ignorerepeated=true,header=2)
  dfλ         = DataFrame(f)
  s           = size(dfλ)
  neig        = s[1]
 
  fWtVr       = "WT_Vr.out"
  f           = CSV.File(fWtVr,skipto=2,stripwhitespace=true,delim=' ',ignorerepeated=true,header=false)
  dfWtVr      = DataFrame(f)

  fWtVi       = "WT_Vi.out"
  f           = CSV.File(fWtVi,skipto=2,stripwhitespace=true,delim=' ',ignorerepeated=true,header=false)
  dfWtVi      = DataFrame(f)
 
  fAdvr       = "AdvectionR.out"
  f           = CSV.File(fAdvr,skipto=2,stripwhitespace=true,delim=' ',ignorerepeated=true,header=false)
  dfAdvr      = DataFrame(f)
  
  fAdvi       = "AdvectionI.out"
  f           = CSV.File(fAdvi,skipto=2,stripwhitespace=true,delim=' ',ignorerepeated=true,header=false)
  dfAdvi      = DataFrame(f)
  
  fLapr       = "LaplacianR.out"
  f           = CSV.File(fLapr,skipto=2,stripwhitespace=true,delim=' ',ignorerepeated=true,header=false)
  dfLapr      = DataFrame(f)
  
  fLapi       = "LaplacianI.out"
  f           = CSV.File(fLapi,skipto=2,stripwhitespace=true,delim=' ',ignorerepeated=true,header=false)
  dfLapi      = DataFrame(f)

  fLap0       = "Laplacian0.out"
  f           = CSV.File(fLap0,skipto=2,stripwhitespace=true,delim=' ',ignorerepeated=true,header=false)
  dfLap0      = DataFrame(f)
  #------------------------------ 

  # Put things in Matrices

  Λ           = zeros(ComplexF64,neig,2)
  for k in 1:neig
    for j in 1:2
      i      = (j-1)*2 + 1
      Λ[k,j] = dfλ[k,i] + im*dfλ[k,i+1]
    end
  end

  WtV         = zeros(ComplexF64,neig,neig)
  for j in 1:neig
  for i in 1:neig
    WtV[i,j]  = dfWtVr[i,j] + im*dfWtVi[i,j]
  end
  end

  Adv         = zeros(ComplexF64,neig,neig,neig)
  for k in 1:neig
    for i in 1:neig
    for j in 1:neig
      l = (k-1)*neig + i
      Adv[i,j,k] = dfAdvr[l,j] + im*dfAdvi[l,j]
    end
    end
  end
  
  Lap         = zeros(ComplexF64,neig,neig)
  for j in 1:neig
  for i in 1:neig
    Lap[i,j] = dfLapr[i,j] + im*dfLapi[i,j]
  end
  end

  Lap0        = zeros(ComplexF64,neig)
  for j in 1:neig
    Lap0[j] = dfLap0[1,j] + im*dfLap0[2,j]
  end

  return Λ, WtV, Adv, Lap, Lap0
end  
#---------------------------------------------------------------------- 
@doc """
      BuildReducedOPMap(p::Abstractmatrix{Int},maxp::Int,nv::Int)

      Build the mappings for the reduced operator and the change of variables.
      Outputs ROPMap object.

"""
function BuildReducedOPMap(NC::Int,NP::Int,NS::Int,X::Vector{T},Y::Vector{T},zerotol::Float64) where {T<:Number}

  nmodes = NC+NP+NS
  cmdim  = NC+NP

  # Read the projections
  Λ, WtV, Adv, Lap, Lap0 = CenterManifold.ReadNekCMFiles()
  
  # Linear Operator
  Lop = zeros(ComplexF64,nmodes,nmodes)
  for i in 1:NC
    Lop[i,i] = Λ[i,1]     # Direct Eigenvalue
    j = NC+1
    Lop[i,j] = Lap0[i]
  end
  # Parameter
  for i in NC+1:cmdim
    Lop[i,i] = 0.0
  end
  # Stable modes
  for i in cmdim+1:nmodes
    j = i-NP
    Lop[i,i] = Λ[j,1]     # Direct Eigenvalue
    k = NC+1
    Lop[i,j] = Lap0[j]
  end

  # Clean up Operator
  Lop2 = copy(Lop)
  SetZero!(Lop2,zerotol)
  ff = eigen(Lop2)
  V  = copy(ff.vectors)
  # Put things in original order
  λ   = zeros(ComplexF64,nmodes)
  for i in 1:nmodes
    λ0         = Lop2[i,i]
    λ[i]       = λ0
    dist       = abs.(ff.values .- λ0)
    i1         = argmin(dist)
    V[:,i]     = ff.vectors[:,i1]
  end
  W  = inv(V)
 
  # Symbols for Variable Transform
  Ws = GenerateSymMatrix("W",nmodes,nmodes)
  nw0 = 0
  Vs = GenerateSymMatrix("V",nmodes,nmodes)
  nv0 = 0
  # Remove unnecessary information
  for ci in CartesianIndices(W)
    if W[ci] == 0
      Ws[ci] = 0
    elseif W[ci] == 1.0
      Ws[ci] = 1.0
    else
      nw0 = nw0+1
    end
  
    if V[ci] == 0
      Vs[ci] = 0
    elseif V[ci] == 1.0
      Vs[ci] = 1.0
    else
      nv0 = nv0+1
    end
  end  
  
  wstovalues = Vector{Tuple{Sym,ComplexF64}}(undef,nw0)
  vstovalues = Vector{Tuple{Sym,ComplexF64}}(undef,nv0)
  
  i = 0
  j = 0
  for ci in CartesianIndices(W)

    if V[ci] == 0 || V[ci] == 1.0

    else
      i = i +1 
      vstovalues[i] = tuple(Vs[ci],V[ci])
    end

    if W[ci] == 0 || W[ci] == 1.0

    else
      j = j +1
      wstovalues[j] = tuple(Ws[ci],W[ci])
    end
  
  end       # ci

  MapVs = Dict(vstovalues)
  MapWs = Dict(wstovalues)

  # Map X to Y
  v  = Vector{Tuple{Sym,Sym}}(undef,nmodes)
  vs = Vector{Tuple{Sym,Sym}}(undef,nmodes)
  xtoy  = V*Y
  xtoys = Vs*Y
  
  # Map Y to X
  w  = Vector{Tuple{Sym,Sym}}(undef,nmodes)
  ws = Vector{Tuple{Sym,Sym}}(undef,nmodes)
  ytox  = W*X
  ytoxs = Ws*X
  
  for i in 1:nmodes
    w[i]  = tuple(Y[i],ytox[i])
    ws[i] = tuple(Y[i],ytoxs[i])
    v[i]  = tuple(X[i],xtoy[i])
    vs[i] = tuple(X[i],xtoys[i])
  end
  X2Y  = Dict(v)
  Y2X  = Dict(w)
  X2Ys = Dict(vs)
  Y2Xs = Dict(ws)

  ROpMap = ROPMap(Lop,Lop2,λ,V,Vs,W,Ws,MapVs,MapWs,X2Y,X2Ys,Y2X,Y2Xs)

  return ROpMap
end
#---------------------------------------------------------------------- 
@doc """
      FillPowers!(p::Abstractmatrix{Int},maxp::Int,nv::Int)

      Fill up matrix p with all combinations of powers over nv variables such that,
      the sum of the powers equals maxp.

"""
function FillPowers!(p::AbstractMatrix{Int},maxp::Int,nv::Int)

  # Not sure how I came up with this but it works.
  # Same as the subroutine in fortran
 
  fill!(p,0)
 
  imax      = NInteractionTerms(maxp,nv)
  if imax == 0
    return nothing
  end
  i         = 1
  jlast     = 1
  
  p[1,1]    = maxp
  
  while (i < imax) 
    pw    = view(p,i,:)
    i     = i + 1
    pw1   = view(p,i,:)

    jlast = NextRow!(pw,maxp,jlast)
        
  end

return nothing
end
#----------------------------------------------------------------------      
@doc """
      GetPowers(maxp::Int,nv::Int)

      Create a matrix p with all combinations of powers over nv variables such that,
      the sum of the powers equals maxp.

"""
function GetPowers(maxp::Int,nv::Int)

  # Not sure how I came up with this but it works.
  # Same as the subroutine in fortran

  imax      = NInteractionTerms(maxp,nv)
  if imax == 0
    return []
  end
  p         = fill(0,imax,nv)
  
  p[1,1]    = maxp
  i         = 1
  jlast     = 1
  
  while (i < imax) 
    pw    = view(p,i,:)
    i     = i + 1
    pw1   = view(p,i,:)
    copyto!(pw1,1,pw,1,nv)

    jlast = NextRow!(pw1,maxp,jlast)
       
  end

return p
end
#----------------------------------------------------------------------
@doc """
      GetNonZeroPowers(maxp::Int,nv::Int)

      Create a matrix p with all combinations of powers over nv variables such that,
      the sum of the powers equals maxp. And all terms have non-zero powers.

"""
function GetNonZeroPowers(maxp::Int,nv::Int)

  # Not sure how I came up with this but it works.
  # Same as the subroutine in fortran

  mp2       = maxp - nv
  p         = GetPowers(mp2,nv)

  for i in eachindex(p)
    p[i] += 1
  end


return p
end
#----------------------------------------------------------------------
@doc """
      QuadTuples(PA::Matrix{Int},nv::Int)

      Get array of Quadratic Interaction terms from a matrix of powers
      PA.

"""
function QuadTuples(PA::Matrix{Int},nv::Int)

  maxp  = 2
  nq    = NInteractionTerms(maxp,nv)
  varno = fill(0,2)

  PTup  = fill(0,nq,2)

  for i in 1:nq
    varno[1] = 0
    varno[2] = 0
    k = 1
    for j in 1:nv
      p = PA[i,j]
      if (p>0)
        if (p == 2)
          varno[1] = j
          varno[2] = j
          k        = 2
          break
        else
          varno[k] = j
          k        = k+1
        end
      end
    end
    PTup[i,1] = varno[1]
    PTup[i,2] = varno[2]
  end 

  return PTup
end
#---------------------------------------------------------------------- 
@doc """
      InteractionNTuples(PA::Matrix{Int},maxp::Int,nv::Int)

      Get array of Interaction terms from a matrix of powers
      PA. The values in the output PTup point to the variable number 
      in the nonlinear term. 

      e.g. for a term v1*v1*v3, PA == [2 0 1] => PTup == [1 1 3]

"""
function InteractionNTuples(PA::AbstractArray{Int},maxp::Int,nv::Int)

  # nq    = NInteractionTerms(maxp,nv)
  nq,nv2  = size(PA)
  varno = fill(0,maxp)

  PTup  = fill(0,nq,maxp)

  for i in 1:nq

    fill!(varno,0)
    k = 1
    for j in 1:nv
      p = PA[i,j]
      if (p>0)
        for l in k:k+p-1
          varno[l] = j
        end
        k = k + p
      end
    end
    for j in 1:maxp
      PTup[i,j] = varno[j]
    end  
  end 

  return PTup
end
#---------------------------------------------------------------------- 
@doc """

      NInteractionTerms(p::Int,nv::Int)

      Get No of interaction terms for nv variables with total power p.
      For example, it is the number of integer solutions for the equation:

      w + x + y + z = P,
      
      with all of nv=4 variables w,x,y,z non-negative and integer P > 0

      The solution would be C(n,k); n = nv+P-1; k = P

"""
function NInteractionTerms(p::Int,nv::Int)

  n = nv+p-1

  return binomial(n,p)
end
#---------------------------------------------------------------------- 
@doc """

      NInteractionTermsNZ(p::Int,nv::Int)

      Get No of interaction terms for nv variables with total power p.
      For example, it is the number of integer solutions for the equation:

      w + x + y + z = P,
      
      with all of nv=4 variables w,x,y,z non-zero and integer P > 0

      The solution would be C(n,k); n = P-1; k=nv-1

"""
function NInteractionTermsNZ(p::Int,nv::Int)

  n = p-1
  k = nv-1

  return binomial(n,k)
end
#---------------------------------------------------------------------- 
@doc """

      TotalInteractionTerms(pmax::Int,nv::Int)

      Get Total No of interaction terms for nv variables with max total power p.

"""
function TotalInteractionTerms(pmax::Int,nv::Int)

  n = 0

  for p in 1:pmax
    n = n + NInteractionTerms(p,nv)
  end  

  return n
end
#---------------------------------------------------------------------- 
@doc """
      NextRow(p0::AbstractArray{Int},maxp::Int,jlast::Int)

      Generate the next row in the matrix for FillPowers!
      or GetPowers. Outputs the new value of jlast, and p

"""
function NextRow(p0::AbstractVector{Int},maxp::Int,jlast::Int)

  p         = copy(p0)
  ns        = length(p)  # No of symbols

  if (iszero(p))
    p[1] = maxp
    jlast  = 1
    return jlast,p
  end
  
  jnext    = jlast + 1
  if (jnext>ns)
    plast  = p[ns]
    p[ns]  = 0
    for j in ns-1:-1:1
      if p[j]>0
        p[j]   = p[j] - 1
        p[j+1] = 1 + plast
        jlast  = j+1
        break
      end
    end
  else
    p[jlast] = p[jlast]-1
    p[jnext] = p[jnext]+1
    jlast    = jnext 
  end

  return jlast,p
end
#----------------------------------------------------------------------
"""
      NextRow!(p::AbstractArray{Int},maxp::Int,jlast::Int)

      Generate in place the next row in the matrix for FillPowers!
      or GetPowers. outputs the new value of jlast.
      p is modified in place.

"""
function NextRow!(p::AbstractVector{Int},maxp::Int,jlast::Int)

  # Single slice
  ns      = length(p)  # No of symbols

  if (iszero(p))
    p[1] = maxp
    jlast  = 1
    return jlast
  end
  
  jnext      = jlast + 1
  if (jnext>ns)
    plast    = p[ns]
    p[ns]  = 0
    for j in ns-1:-1:1
      if p[j]>0
        p[j]   = p[j] - 1
        p[j+1] = 1 + plast
        jlast  = j+1
        break
      end
    end
  else
    p[jlast] = p[jlast]-1
    p[jnext] = p[jnext]+1
    jlast    = jnext 
  end

  return jlast
end
#----------------------------------------------------------------------
"""
      UpdatePolynomialIndex!(ind::AbstractVector{Int},ord::Int,nc::Int)
      
      Generate the nth row in the matrix for GetPowers.

"""
function UpdatePolynomialIndex!(ind::AbstractVector{Int},ord::Int,nc::Int)

  itmp = minimum(ind)
  # First index
  if (itmp == -99)
    fill!(ind,0)
    return
  elseif (itmp < 0)
    println("Invalid Starting indices, $ind")
  end

  for oi = ord:-1:1
    itmp = ind[oi]
    if (itmp < (nc-1)) 
      itmp = itmp + 1 
      for ii in oi:ord
        ind[ii] = itmp
      end
      return nothing
    end     # itmp.eq.nc
  end       # oi
        
  # If we are here then we are at the end of 
  # polynomial indices.
  for oi=1:ord
    ind[oi] = -ind[oi]
  end 

  return nothing
end  
#---------------------------------------------------------------------- 
"""
      GetPolynomialIndices(n::Int,ord::Int,nc::Int)
      
      Generate the nth row in the matrix for GetPowers.

"""
function GetPolynomialIndices(n::Int,ord::Int,nc::Int)

  Nt = NInteractionTerms(ord,nc)
  ind = fill(-99,ord)

  if n > Nt
    println("n greater than total terms, $n, $Nt")
  else
    for i in 1:n
      UpdatePolynomialIndex!(ind,ord,nc)
    end
  end

  return ind
end
#---------------------------------------------------------------------- 
function newindex(jo::Int,nc::Int,np::Int,ns::Int)

  cm  = nc + np     # Center Manifold Dimension
  dm  = nc + ns     # Total dynamic modes
  nm  = cm + ns     # Total modes
  
  if (jo<=nc)
    jn = jo
  elseif (jo>nc) && (jo<=dm)
    jn = jo + np
  elseif (jo>dm)
    if (jo>nm)
      error("invalid old mode no.")
    else
      jn = jo - ns
    end
  end

  return jn
end
#---------------------------------------------------------------------- 
function oldindex(jn::Int,nc::Int,np::Int,ns::Int)

  cm  = nc + np     # Center Manifold Dimension
  dm  = nc + ns     # Total dynamic modes
  nm  = cm + ns     # Total modes
  
  if (jn<=nc)
    jo = jn
  elseif (jn>nc) && (jn<=cm)
    jo = jn + ns
  elseif (jn>cm)
    if (jn>nm) 
      error("invalid new mode no.")
    else
      jo = jn - np
    end
  end

  return jo
end
#---------------------------------------------------------------------- 
function SetZero!(A,tol)

  n = length(A)
  el = eltype(A[1])
  zro = el(0)
  for i in 1:n
    if abs(A[i])<tol
      A[i] = zro
    end
  end

  return nothing
end  
#---------------------------------------------------------------------- 
"""
      GetInteractionTerms(n::ord::Int,nc::Int)
      
      Generate the nth row in the matrix for GetPowers.

"""
function GetInteractionTerms(n::Int,Ord::Int,nv::Int)

  vars = fill(-99,Ord)
  nt   = NInteractionTerms(Ord,nv)

  if n > nt
    error("n greater than total terms.")
  end

  for i in 1:n 
    UpdatePolynomialIndex!(vars,Ord,nv)
  end  

  return vars
end
#---------------------------------------------------------------------- 
"""
      GetInteractionIndex(vars::AbstractVector{Int},nv::Int)
      
      Get the index of non-linear interaction terms.

"""
function GetInteractionIndex(vars::AbstractVector{Int},nv::Int)

  Ord       = length(vars)
  nt        = NInteractionTerms(Ord,nv)

  vsort     = sort(vars)
  v2        = fill(-99,Ord)
  varmax    = maximum(vars)

  # Numbering starts from 0
  if varmax >= nv
    error("variable number in array greater than maximum number of variables")
  end

  ind = 0
  for i in 1:nt 
    UpdatePolynomialIndex!(v2,Ord,nv)
    if v2 == vsort
      ind = i
      break
    end  
  end  

  return ind
end






